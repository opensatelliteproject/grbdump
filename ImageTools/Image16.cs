using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;

namespace OpenSatelliteProject.ImageTools {
    public class Image16 {

        public int Width { get; private set; }
        public int Height { get; private set; }

        public ushort MaxValue { 
            get { 
                if (dirty) {
                    ComputeMinMax ();
                }

                return cachedMax;
            }  
        }
        public ushort MinValue { 
            get {
                if (dirty) {
                    ComputeMinMax ();
                }

                return cachedMin;
            }
        }

        ushort[][] data;
        bool dirty;
        ushort cachedMax = 0;
        ushort cachedMin = 0xFFFF;

        public Image16 (int width, int height) {
            this.Width = width;
            this.Height = height;
            data = new ushort[height][];
            for (int i = 0; i < height; i++) {
                data[i] = new ushort[width];
            }
            dirty = true;
        }

        public void DrawImage(Image16 src, Rectangle srcRect, int posX, int posY) {
            for (int y = srcRect.Y; y < srcRect.Height; y++) {
                int targetX = Math.Min(posX, 0);
                int lenX = Math.Min(srcRect.Width - targetX, Width - targetX);
                int targetY = y + posY;
                if (targetY > 0 && targetY < Height) {
                    Buffer.BlockCopy (src.data [y], srcRect.X * sizeof(ushort), data [targetY], targetX * sizeof(ushort), lenX);
                }
            }
            dirty = true;
        }

        public void DrawImage(int[] src, int srcWidth, Rectangle srcRect, int posX, int posY) {
            for (int y = srcRect.Y; y < srcRect.Height; y++) {
                int targetY = posY + y;               
                for (int x = srcRect.X; x < srcRect.Width; x++) {
                    int targetX = posX + x;
                    if ((targetX > 0 && targetX < Width) && (targetY > 0 && targetY < Height)) {
                        data [targetY] [targetX] = (ushort)Clamp (src [y * srcWidth + x], 0, 65535);
                    }
                }
            }
            dirty = true;
        }

        public Bitmap ToBitmap() {
            Bitmap bmp = new Bitmap (Width, Height, PixelFormat.Format8bppIndexed);

            var pal = bmp.Palette;
            for (int i = 0; i < 256; i++) {
                pal.Entries [i] = Color.FromArgb (i, i, i);
            }

            bmp.Palette = pal;

            BitmapData bmpData = bmp.LockBits (new Rectangle (0, 0, Width, Height), ImageLockMode.WriteOnly, PixelFormat.Format8bppIndexed);
            unsafe {
                var bData = (byte *)bmpData.Scan0;
                for (int y = 0; y < Height; y++) {
                    for (int x = 0; x < Width; x++) {
                        int c = y * bmpData.Stride + x;
                        bData [c] = (byte)Clamp(data [y] [x], 0, 255);
                    }
                }
            }
            bmp.UnlockBits (bmpData);
            return bmp;
        }

        public void SavePGM(string filename) {
            using (FileStream fs = new FileStream(filename, FileMode.OpenOrCreate, FileAccess.Write)) {
                using (BinaryWriter bw = new BinaryWriter(fs)) {
                    string head = $"P5\n# Generated by OpenSatelliteProject\n{Width} {Height}\n65535\n";
                    for (int i = 0; i < head.Length; i++) {
                        bw.Write ((byte)head[i]);
                    }

                    for (int y = 0; y < Height; y++) {
                        for (int x = 0; x < Width; x++) {
                            byte[] b = BitConverter.GetBytes (data [y] [x]);
                            if (BitConverter.IsLittleEndian) {
                                Array.Reverse (b);
                            }
                            bw.Write(b, 0, 2);
                        }
                    }
                }
            }
        }

        static int Clamp( int value, int min, int max ) {
            return (value < min) ? min : (value > max) ? max : value;
        }

        public void ScaleToBits(int numBits) {
            float maxVal = (float) Math.Round(Math.Pow (2, numBits)) - 1;
            RemoveOffset ();
            float scale = cachedMax / maxVal;
            for (int y = 0; y < Height; y++) {
                for (int x = 0; x < Width; x++) {
                    data [y][x] = (ushort) (data [y][x] / scale);
                }
            }
            dirty = true;
        }

        public void RemoveOffset() {
            ushort min = MinValue;
            for (int y = 0; y < Height; y++) {
                for (int x = 0; x < Width; x++) {
                    data [y][x] -= min;
                }
            }
            cachedMax -= min;
            cachedMin = 0;
        }

        void ComputeMinMax() {
            for (int y = 0; y < Height; y++) {
                for (int x = 0; x < Width; x++) {
                    cachedMax = Math.Max (cachedMax, data [y][x]);
                    cachedMin = Math.Min (cachedMin, data [y][x]); 
                }
            }
            dirty = false;
        }
    }
}

